=Mockito vs EasyMock=

  List mock = createNiceMock(List.class);				List mock = mock(List.class);
  
  expect(mock.add("one")).andStubReturn(true);			stub(mock.add("one")).toReturn(true);
  
  mock.clear();
  
  replay(mock);
  
  someCodeThatInteractsWithMock();						someCodeThatInteractsWithMock();
  
                                                        verify(easy).clear();
  
  verify(easy);											
  
                                                        verifyNoMoreInteractions(mock);
  
===Mockito's similarities:===

  * allow the same level verification as EasyMock (unexpected invocations, redundant invocations, strict verification)
  
  * argument matchers (anyInt(), anyObject(), etc.)

===Mockito's differences:===

  * only one kind of mock (no nice/default/strict mocks). 
  Using EasyMock metaphor: Mockito mocks can be nice or strict - but it depends on how you verify mocks, not how you create them.
  Because there is only one kind of mock - it is easier to share setup 
  (situations where mocks are fields in test class but different test methods require different kinds of mocks).
  
  * no record/replay modes - no need for them. There only 2 things you can do with Mockito mocks - verify or stub. 
  Stubbing goes before execution and verification afterwards.

  * all mocks are 'nice' (even nicer than EasyMocks, because collection-returning methods return empty collections instead of nulls).
  Even though mocks are nice, you can verify them as strictly as you want and detect any unwanted interaction.
  
  * verification is explicit - verification errors point exactly what interaction failed.
  
  * simplified stubbing model - stubbed methods replay all the time with stubbed value no matter how many times they are called.
   Works exactly like EasyMock's andStubReturn(), andStubThrow(). Verification of stubbed methods is optional because usually it's more important
   to test if the stubbed value is used correctly rather than where's it come from.
  
  * only one way of creating mocks (no MockControl object).
  
  * single jar distribution.
  
=Strict verification=  
    
  Control control = createStrictControl();  
  
  List one = control.createMock(List.class);				List one = mock(List.class);
  List two = control.createMock(List.class);				List two = mock(List.class);
  
  expect(one.add("one")).andReturn(true);
  expect(two.add("two")).andReturn(true);
  
  control.replay();
  
  someCodeThatInteractsWithMocks();							someCodeThatInteractsWithMocks();

                                                            Strictly strictly = strictly(one, two);
                                                            
                                                            strictly.verify(one).add("one");
                                                            strictly.verify(two).add("two");
  
  control.verify();											
  
=Stubbing void methods=

  List mock = createNiceMock(List.class);					List mock = mock(List.class);
  
  mock.clear();												stubVoid(mock).toThrow(new Exception()).on().clear();
  expectLastCall().andThrow(new Exception());
  
  replay(mock);